"""
문제 자체는 쉬우나 dp로 풀어야한다는 강박 때문에 시간이 오래 걸린 문제
테스트에서 마주칠 경우 알고리즘은 문제를 해결하기 위한 수단으로 사용해야한다. (알고리즘 쓰기 위해 푸는 것이 아니다.)
순열로  풀고 팩토리얼 사용과정에서 dp사용
+
인줄 알았으나 동적계획(dp)를 이용하여 간단히 해결 가능한 문제
풀이: n번째 항에서의 dp[n]의 값은
1. dp[n-1]의 경우들에서 1을 더한 것
2. dp[n-2]의 경우들에서 2를 더한 것
3. dp[n-3]의 경우들에서 3를 더한 것
3가지 이고 3가지는 서로 중복되지 않는다.
또한 1,2,3으로만 표현되므로 빠뜨리고 세는 경우도 없다.
"""
import sys

T = int(sys.stdin.readline())
dp = [0 for _ in range(11)]
dp[1], dp[2], dp[3] = 1, 2, 4
for i in range(4, 11):
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
for _ in range(T):
    print(dp[int(sys.stdin.readline())])
